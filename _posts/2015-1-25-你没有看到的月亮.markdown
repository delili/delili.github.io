---
author: deli
comments: true
date: 2015-01-25 22:04:09+00:00
layout: post
title: 你没有看到的月亮
categories:
- 生活
tags:
- 总结
- 反思
---

---------
生活
---------
      
四年武汉的生活，有点不太习惯这么长的北方的冬天，光秃秃的树枝，枯萎的草木像是在告诉我，“孩子，醒醒，你现在是在北方了”。北方的冬天因为有暖气这个必杀技相对来说我更偏爱一些，以前听说南方很多新建的小区也开始有集体供暖了，甚是欣慰。

离家近了，我也只在十一的时候回家待了3天，不知道是不是在武汉习惯了长时间不回家，到这边一时间还没转换过来。

这学期台球打得比较多，没事的情况下每周都会去参加台协的周赛，有一群球友是幸福的，特别是可以肆无忌惮的在群里约球，基本上你什么时候想打都可以找到人，甚好。考虑这下学期来了入一根球杆，也希望能自己的水平能够提高一些。羽毛球就打了一次，线还被打断了，可能是因为冬天太冷太干的原因吧，昨天去拉线顺便去隔壁找浩哥蹭了顿饭，也感谢浩哥带我吃鱼。

前两天一个去深圳工作的高中好基友打电话过来聊天，说自己辞职了，说实话，听到这话的时候我还是有点惊讶的，毕竟也才入职半年，可能是这份工作跟他预想的相差太大吧。《月亮和柳便士》好像是他比较喜欢的，所以这篇文章的题目我也取了一个相关的题目。

写文章的时候扫了一下豆瓣上记录的这学期看的书，发现已经落下很多了，不能静下心来看书做事总是不行的。

---------
学习
---------
      
这学期的课程不是很多，主要想在这吐槽一下自己的操作系统面测，因为是结合MIT的jos课程，线下实现起来是比较蛋疼的，学着用vim来看代码，感觉还挺舒服的，说说最后的水水的面测吧。

说实话没想助教会问最后的进程间通信，自己在复习的时候也一直在看调度，中断那些东西，忽略了最后一部分的内容，所以也是当时问的时候当场看当场答的。

实验中的简单进程通信是通过两个系统调用`sys_ipc_recv` 和 `sys_ipc_try_send`,以及他们在用户库中的包装 `ipc_recv` 和 `ipc_send`实现的。

接收消息:进程调用 `sys_ipc_recv`,系统阻塞当前进程,直到消息被接收到。当一个进程在等待接收消息时,任何其他进程都可以向它发送消息。
     
发送消息:进程给定接收进程的 `id` 和待发送的内容,调用 `sys_ipc_try_send`,如果目标进程的确在等待消息,那么就将消息传递过去并返回0;否则返回`-E_IPC_NOT_RECV` 表示目标进程当前并不在等待接收消息。

>     static int    
    sys_ipc_recv(void *dstva)    
    {
       // LAB 4: Your code here.   
        if (((uint32_t)dstva < UTOP) && ROUNDDOWN(dstva , PGSIZE) != dstva)        
            return -E_INVAL;    
        curenv->env_ipc_recving = 1;
        curenv->env_status = ENV_NOT_RUNNABLE;
        curenv->env_ipc_dstva = dstva;
	    curenv->env_ipc_from = 0;
	    sched_yield ();
        return 0;
	    //panic("sys_ipc_recv not implemented");
    }


题目大意：进程在等待接收消息的时候是阻塞式的还是非阻塞式的，在哪里设置的，为什么？
其实问题不难，只是当时实现的时候没有认真去理解助教问题的意思，加上自己对这部分不求甚解的缘故，这道题就没有答出来。

答案其实很简单，就是在`curenv->env_status = ENV_NOT_RUNNABLE`中设置进程状态为`ENV_NOT_RUNNABLE`,在轮询的时候就不会选择此进程再次上CPU。

简单的一道题，其实反可以反映出我对于这部分甚至整个实验的理解程度。

反思良久，需要认真。





